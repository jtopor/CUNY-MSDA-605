---
title: "DATA 605 Asn 1"
author: "James Topor"
date: "January 31, 2016"
output: html_document
---

__Problem Set 1__

__1. Calculate dot product of u = [0.5, 0.5], v = [3, -4]__

We can calculate the dot product by taking the transpose of vector 'u' and multiplying the result by vector 'v':
```{r}

# initialize vectors u and v
u <- matrix(c(0.5, 0.5))
v <- matrix(c(3, -4))

# calculate dot product of vectors u and v
dotprod <- t(u)%*%v
dotprod
```

The dot product of u and v is -0.5

__2. What are the lengths of u and v?__

We find the lengths of u and v by calculating the square root of the sum of the squares of the individual components of each vector:
```{r}
# Length of vector u
lenU <- sqrt(sum(u^2))
lenU

# Length of vector v
lenV <- sqrt(sum(v^2))
lenV
```

The length of u is therefore 0.7071068, while the length of v is 5.


__3. What is the linear combination: 3u - 2v?__

```{r}
3*u - 2*v
```


__4. What is the angle between u and v?__

```{r}
# divide dot product by product of vector lengths to get cosine of theta
cosTheta <- dotprod / ( lenU * lenV )
cosTheta

# get angle in terms of radians by finding the inverse cosine of the cosine of theta
theta <- acos(cosTheta)
theta

# convert radians to degrees
theta * (180 / pi )
```
               
The angle is __1.712693 radians__, or __98.13 degrees__.  
  
  
__Problem Set 2__

Write a function to solve a system of 3 equations in 3 unknowns in the form Ax = b. NOTE: This only works if the system has solutions for all 3 variables. If the system has any singularities it doesn't work.

Our system of equations is given as:

1x + 1y + 3z = 1  
2x + -1y + 5z = 2  
-1x + -2y + 4z = 6

We can check the solution to this system of equations in R as follows prior to writing a separate function:

```{r}
a <- rbind(c(1, 1, 3), 
           c(2, -1, 5), 
           c(-1, -2, 4))
b <- c(1, 2, 6)
solve(a, b)
```

We'll use the above to check the validity of the output of the new function we create below.

```{r}

# Inputs to solve3x3 function are 'a': a 3x3 matrix; and 'b': a 1x3 vector

solve3x3 <- function(a, b) {
  #creat a numeric vector of size 3 to store function outputs.
  x = numeric(3)

  # attach vector b to matrix a to create augmented matrix
  augm = cbind(a, b)
  # augm

  # Now that we have the augmented matrix in proper format, we can start
  # row reduction operations to solve for the vector x

  # ---------------------------------------------------------------
  # Step 1: get a 1 in upper left pivot position
  if (augm[1,1] == 0) {
    #  need to swap with other row that has non-zero in first column
    if (augm[2,2] != 0) {
    # switch rows 1 and 2 since row 2 has a non-zero in col 1
    augm = augm[c(2,1,3),]
    } else {
    # else switch rows 3 and 1 since row 3 MUST have a non-zero
      augm = augm[c(3,2,1),]
    }

  }  else if (augm[1,1] != 1) {
    # else divide 1st row by R1C1 to get 1 in pivot
    augm[1, ] <- augm[1, ] / augm[1,1]
  }  
  
  # augm

  # ---------------------------------------------------------------
  # Step 2: zero out other entries in col 1
  if (augm[2,1] !=0) {
    # use value of r2c1 as basis for vector addition to zero out row
    tempvec <- augm[2,1] * augm[1, ]
    # now reduce row 2 using tempvec
    augm[2, ] <- -augm[2, ] + tempvec
  }
 
  # augm
   
  if (augm[3,1] !=0) {
    # use value of r3c1 as basis for vector addition to zero out R2C1
    tempvec <- augm[3,1] * augm[1, ]
    # now reduce row 2 using tempvec
    augm[3, ] <- -augm[3, ] + tempvec
  }

  # augm

  # ---------------------------------------------------------------
  # Step 3: Now repeat steps 1 and 2 for row 2
  # check if R2C2 == 0. If it does, swap w/ row 3 to get non-zero in R2C2
  if (augm[2,2] == 0) {
    # switch rows 2 and 3 since row 2 has a zero in col 2
    augm = augm[c(1,3,2),]
  } 

  # divide 2nd row by R2C2 to get 1 in pivot
  augm[2, ] <- augm[2, ] / augm[2,2]
  # augm

  # use value of r3c2 as basis for vector addition to zero out R3C2
  tempvec <- augm[3,2] * augm[2, ]
  # now reduce row 3 using tempvec
  augm[3, ] <- -augm[3, ] + tempvec  

  # check augm to see if we have upper echelon format
  # augm


  # Solve for vector x by back subsitution
  x[3] <- augm[3,4] / augm[3,3]
  x[2] <- (augm[2,4] - augm[2,3]*x[3]) / augm[2,2]
  x[1] <- (augm[1,4] - augm[1,2]*x[2]- augm[1,3]*x[3]) / augm[1,1]

  x

  return(round(x,2))
}


# main body of test code: create matrix a and vector b, call 3x3 solver
# function

a <- rbind(c(1, 1, 3), 
           c(2, -1, 5), 
           c(-1, -2, 4))
b <- c(1, 2, 6)

# a
# b

solve3x3(a,b)

```

As we can see, the output of our new function matches that of R's native __solve__ function, thereby validating the code we've constructed for the function.