---
title: "CUNY MSDA 605 Spring 2016 Assignment 4"
author: "James Topor"
output: html_document
---

### Problem Set 1  

1. Write code to compute $X = AA^T$ and $Y = A^TA$ and get eigenvalues and eigenvectors for X and Y using R's native functionality

```{r}
# Create required matrix A
A <- rbind(c(-1, 1, 5), 
           c(1, 3, 0),
           c(0, -2, 1))

# Calculate A * A^T
x <- A %*% t(A)
x

# Calculate A^T * A
y <- t(A) %*% A
y

# get eigen values + vectors of x and y using built-in R functions
xEigen <- eigen(x)
xEigen

yEigen <- eigen(y)
yEigen
```

2. Find left-singular vectors, singular values, and right-singular vectors of A using the __svd__ command
```{r}
Asvd <- svd(A)

# Display left-singular vector for matrix A
Asvd$u

# Display singular values for matrix A
Asvd$d

# Display right-singular values for matrix A
Asvd$v
```

Now we can compare the output of the __svd__ function to the eigen vectors we derived using R's native __eigen__ function to determine whether or not the vectors __svd__ generated are eigenvectors of X and Y.

We start by comparing the eigenvectors generated by R's native __eigen__ function for matrix X against the vector of left-singular values generated by the __svd__ function for matrix A:

```{r}
xEigen$vectors

Asvd$u
```

As we can see, the results are numerically equivalent, with the first left-singular vector of A varying from the first eigenvector of X in sign(+/-) only while the other two left-singular vectors are identical.



Now let's compare the eigenvectors generated by R's native __eigen__ function for matrix Y against the vector of right-singular values generated by the __svd__ function for matrix A:

```{r}
yEigen$vectors

Asvd$v
```

As we can see, the right-singular vectors of A match up to the eigenvectors of Y, with the first and third right-singular vectors varying from the first and third eigenvectors of Y in sign(+/-) only. 

As such, the singular vectors generated by R's __svd__ function are indeed eigenvectors of A.

Next, we examine the non-zero eigenvalues of X and Y to see if they are the same:
```{r}
round(xEigen$values, 3)
round(yEigen$values, 3)

round(xEigen$values, 3) == round(yEigen$values, 3)
```

As we can see, they are indeed the same.

Finally, we examine the non-zero eigenvalues of X and Y to see if they are in fact squares of the non-zero singlular values of A:

```{r}
# square the non-zero singular values of A
round(Asvd$d^2, 3)

# square the non-zero singular values of A and compare to the eigenvalues of X
round (Asvd$d^2, 3) == round(xEigen$values, 3)

# square the non-zero singular values of A and compare to the eigenvalues of Y
round (Asvd$d^2, 3) == round(yEigen$values, 3)

```

As we can see, squaring the non-zero singular values of A does, in fact, produce the eigenvalues of matrices X and Y.


### Problem Set 2  

Write a function to compute the inverse of a well-conditioned full rank matrix using cofactors.

We can define our __myinverse__ function as follows:

```{r}
myinverse <- function(A) {

  # check dimensions of A to ensure squareness
  rows <- nrow(A)
  cols <- ncol(A)

  # check to ensure we have a square matrix. If not, exit the function
  if ( rows != cols) {
    print("Input Matrix is NOT a square matrix")
    return()
  }

  # create a matrix to store the cofactors of A
  cofacA <- matrix(NA, rows, cols)
  
  # iterate over each row,col element of A and compute A's cofactor matrix
  for(i in 1:rows)
    for(j in 1:cols) {
      # correct sign for cofactor (+ or -) is found by raising -1 to the (i+j)th power.
      # Placing negative signs in front of the row and col indices removes those rows and columns
      # from the matrix A before it is passed to R's 'det' function. So A[-i, -j] is the minor of A[i,j]
      cofacA[i,j] <- (-1)^(i+j) * det( A[-i,-j] )
    } # end cols
  
  # now use formula from Lecture Notes: divide t(cofacA) / det(A) to get the inverse of A
  invA <- t(cofacA) / det(A)
  
  return(invA)
}
```


Now to test the function we've written: 

### Test a 3x3 Matrix
```{r}
# Test 3x3
A <- rbind(c(1, 3, -2), 
           c(4, 0, 1), 
           c(5, 3, 2))

invA <- myinverse(A)

# display the inverse of A
invA

# Now multiply A by its inverse to ensure that the product is the identity matrix
round(A %*% invA, 3)
```


### Test a 4x4 Matrix
```{r}
# Test 4x4
A <- rbind(c(1, 1, 5, 4), 
           c(2, 3, 4, 2), 
           c(3, 2, 3, 2),
           c(4, 4, 2, 1))

invA <- myinverse(A)

# display the inverse of A
invA

# Now multiply A by its inverse to ensure that the product is the identity matrix
round(A %*% invA, 3)
```