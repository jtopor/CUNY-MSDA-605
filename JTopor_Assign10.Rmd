---
title: "CUNY MSDA 605 Spring 2016 Assignment 10"
author: "James Topor"
output: html_document
---

# Playing with PageRank

# -----------------------------------------------------------------------------

__1.__ *Form the A matrix as per the lecture notes*:
```{r}
A <- matrix(c(  0,  0,1/4,  0,  0,  0, 
              1/2,  0,1/4,  0,  0,  0, 
              1/2,  1,  0,  0,  0,1/2, 
                0,  0,  0,  0,1/2,1/2, 
                0,  0,1/4,1/2,  0,  0, 
                0,  0,1/4,1/2,1/2,  0), nrow=6, byrow=TRUE)
A
```

*Initialize the decay value and create matrix B*:
```{r}
d <- 0.85
k <- nrow(A)
B <- d * A + ((1-d)/k)
B
```

# -----------------------------------------------------------------------------

__2.__ *Start with a uniform rank vector r and perform power iterations on B until convergence. That is, complute the solution $r = B^n x r$. Use a sufficiently large 'n' so that 'r' actually converges.*

We start by creating a vector __rVec__, having a length of __k__ where __k__ is the dimension of our matrix A from above. We then make a copy of matrix __B__ for use within the *for* loop that will perform the required power iteration. We then set the value for __n__ to be 20 so that we perform 20 power iterations on matrix __B__ before multiplying the result by vector __rVec__ to obtain the solution to the equation $r = B^n x r$.

```{r}
# create a uniform rank vector 'r' of length 'k' where 'k' = the dimension of matrix A as defined above
rVec <- rep(1/k, k)

# display the uniform rank vector
rVec

# make a copy of matrix B to be used for power iteration loop
Bclone <- B

# now iterate on B until convergence
n <- 20
for (i in 1:n)
  Bclone <- B %*% Bclone

# multiply results of iteration by vector r
rf <- Bclone %*% rVec
```

The final vector produced by the power iteration method is:

```{r}
# display results
rf
```

# -----------------------------------------------------------------------------

__3.__  *Compute the eigen-decomposition of B and verify that we get an eigenvalue of 1 as the largest eigenvalue and that the eigenvector is the same vector obtained via power iteration. Eigenvector should also have all positive entries and sum to 1.*

We'll use R's __eigen__ function to compute the decomposition. We can then directly examine the eigenvalues of B:
```{r}
eigB <- eigen(B)
eigB$values
```

We can see that the largest eigenvalue is, in fact, 1.  

The corresponding eigenvector is:
```{r}
eigB$vectors[,1]
```

The values in the vector don't match the values we obtained via iteration. However, this is to be expected since R's __eigen__ function may have been calculated via a different mathematical approach. Despite their values not appearing to be equivalent, they may in fact actually be equivalent and may only differ from one another by some as yet unknown scalar multiplier.

We can check this by dividing the values within our final power iteration vector __rf__ by the corresponding elements of the eigenvector to see if we obtain a single common result:

```{r}
rf / eigB$vectors[,1]
```

As we can see, each of the values of the eigenvector can be scaled by a common scalar to obtain the vector we obtained via iteration. Specifically, scaling the eigenvector by (-0.4334254) will yield vector __rf__ :

```{r}
evScaled <- -0.4334254 * eigB$vectors[,1]
evScaled
```

As we can see, the values of the vector __evScaled__ match the values we obtained earlier for our vector __rf__. The vector __rf__ is transposed here to allow for easier visual comparison with the values of __evScaled__ shown above:

```{r}
t(rf)
evScaled
```


Now we can verify that the vector does sum to 1:
```{r}
round(sum(evScaled), 4)
```

# -----------------------------------------------------------------------------

4. *Use __igraph__ and its __page.rank__ method to compute the graph as given in A. Verify that you get the same PageRank vector as obtained via iteration and eigen decomposition.*

After reviewing the documentation for the __igraph__ package, it appears that we'll need to apply the __graph.adjacency__ function to our original matrix __A__ in order to generate an R object that can be interpreted by the __page.rank__ function. Use of the __graph.adjacency__ function apparently requires that we transpose our original matrix __A__ if we are to obtain accurate results:

```{r, message=FALSE, warning=FALSE}
library(igraph)

# transpose matrix A - required for proper calculations + graphing
GraphObj <- graph.adjacency(t(A), mode="directed", weighted=TRUE, diag=TRUE)

page.rank(GraphObj)
```

As we can see, the __page.rank__ method does, in fact, yield the same PageRank vector as obtained via iteration and eigen decomposition.

We can then plot the resulting graph to verify that it matches Figure 1 from the lecture notes:
```{r}
plot.igraph(GraphObj)
```