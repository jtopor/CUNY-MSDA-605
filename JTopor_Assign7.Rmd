---
title: "CUNY MSDA 605 Spring 2016 Assignment 7"
author: "James Topor"
output: html_document
---

### Problem Set 1
# --------------------------------------------------------

*Write a function to compute the expected value and standard deviation of an array of values and compare the results to R's native __mean__ and __sd__ functions.*

We'll start by defining a function to calculate the mean of a vector of numbers. This is quite simple in R since R is a vector-based computational environment. To find the mean of a vector we simply calculate the sum of all items within the vector and divide that sum by the number of elements in the vector. We can make use of R's __length__ function to compute the number of elements within a vector:
```{r}
# Function that calculate the mean of a vector of numbers
calc_mean <- function(vec) sum(vec) / length(vec)
```

To find the standard deviation we'll need to make use of the fact that the variance of a random variable $x$ (referred to here as $Var(x)$) is:

$$Var(x) = E((x - E(x))^2)$$

and the standard deviation of a random variable 'x' is:

$$\sqrt(Var(x)$$

The 'calc_mean' function we defined above computes the expected value of a vector for us. Therefore, we can make use of that function within the new function we need to create to calculate the standard deviation of a vector. Using the variance formula shown above, We'll calculate the standard deviation as follows:

__1)__ Start by subtracting the mean of the vector from each element of the vector using our 'calc_mean' function:

- vec - calc_mean(vec)

__2)__ We then sum the results of Step 1 and square them, resulting in the follow R code:

- sum(vec - calc_mean(vec))^2

__3)__ At this point we have $(x - E(x))^2$. To find the expected value of that function (and complete our calculation of the variance) we simply divide the results of Step 2 by the number of items within the vector, giving us the following R code:

- sum((vec - calc_mean(vec))^2)/length(vec)

__4)__ Finally, we take the square root of the variance as calculated in Step 3, giving us the complete forumula for calculating the standard deviation:

- sqrt(sum((vec - calc_mean(vec))^2)/length(vec))

Now that we've got the complete formula we can formally define our new function for calculating the standard deviation:
```{r}
# function that calculates the standard deviation of a vector of numbers
# NOTE: it relies on the 'calc_mean' function defined above AND computes the 
# standard deviation for a population, NOT a sample. Hence denominator = n and not n-1
calc_sd <- function(vec) sqrt(sum((vec - calc_mean(vec))^2)/length(vec))
```

It is important to note that the formula for the standard deviation as described here caclulates the standard deviation of a *population* rather than a *sample* since we are dividing the results of $(x - E(x))^2$ by $n$, the number of items in the vector. To correctly calculate the standard deviation of a sample we would need to divide $(x - E(x))^2$ by $(n - 1)$.

Let's test our new functions and compare their results to those of R's native __mean__ and __std__ functions:
```{r}
# test the functions and compare to output of R's native 'mean' function
vec1 <- c(1, 2, 3, 4, 5)
calc_mean(vec1)
mean(vec1)

calc_sd(vec1)
sd(vec1)

# test with a different vector
vec2 <- c(147, -324, 42, 0, 76, 88, -13)
calc_mean(vec2)
mean(vec2)

calc_sd(vec2)
sd(vec2)
```

As we can see, the results of R's 'mean' function are identical to those of our 'calc_mean' function. 
However, the results of R's 'sd' function do not match those of our 'calc_sd' function. This is due to the fact that R's 'sd' function calculates the standard of a *sample* rather than that of a *population*. 

In fact, if we alter our new standard deviation function so that it divides $(x - E(x))^2$ by $(n - 1)$ we'll find that the two functions produce identical results:

```{r}
# function that calculates the standard deviation of a vector of numbers using the sample (n-1) method
calc_sdsamp <- function(vec) sqrt(sum((vec - calc_mean(vec))^2)/(length(vec)- 1))

calc_sdsamp(vec1)
sd(vec1)

calc_sdsamp(vec2)
sd(vec2)

```


# --------------------------------------------------------
*Now, consider that instead of being able to neatly fit the values in memory in an array,you have an infinite stream of numbers coming by. How would you estimate the mean and standard deviation of such a stream?*

If we have an infinite stream we can make use of the fact that any new value we see from the stream will change the mean we've calculated up to that point only if the new value *varies* from that previous mean. In other words, we're really only interested in the difference between the newly observed value and the old mean: the difference of those two amounts gets divided by the updated count of elements, and adding the result to our old mean produces the updated mean.

Therefore, the items we need to compute a running mean are:

- $n$ = the number of items we've examined from the infinite stream thus far (inclusive of the new item);
- $\mu(previous)$ = the mean of all previous items we've seen thus far;
- $Stream[n] - \mu(previous)$ = the difference between the new value we're examining ($Stream[n]$) and the mean of the previous $(n-1)$ stream elements seen thus far.

Since these are the only three items required to compute the new mean, we only need to maintain two values in memory on an ongoing basis to maintain a "streaming mean":

1) A running sum $n$ of the number of stream items seen thus far;

2) The value of $\mu(previous)$

The formula for the streaming mean can then be stated as:

$$\mu(new) = \mu(previous) + ((Stream[n] - \mu(previous))/n)$$

where $\mu(new)$ is the updated value of the mean after considering the latest stream item $Stream[n]$.

For the standard deviation, we can see from the variance formula $( Var(x) = E((x - E(x))^2) )$ that we can similarly make use of an iterative approach: the variance will change only if the value of the newly observed item varies from the "old", or 'previous', mean. This can be seen by simply rewriting the $( x - E(x) )$ portion of the variance equation as $( Stream[n] - \mu(previous) )$: if the value of the new item is identical to that of the previous mean, neither the mean nor the variance will change at all since $( Stream[n] - \mu(previous) )$ will be equal to zero. 

However, if the value of the new item is NOT identical to the previous mean, we need to determine how much additional variability the new item adds to the variability metric we've previously calculated. According to __Wellford__ (see citation below), an effective way to do this is to update the sum of squares of differences from the current mean as follows:

- Sum of Squares of Differences $M(n) = M(previous) + (Stream[n] - \mu(n-1)) * (Stream[n] - \mu(n))$

where $M(previous)$ is the previously calculated sum of squares of differences, $\mu(n-1)$ is the previous value of the mean prior to the observation of the new data stream value $Stream[n]$, and $\mu(n)$ is the new value of the mean calculated after observing the new data stream value.

We then estimate the standard deviation by taking the square root of $M(n)$ divided by the total number of data stream items observed $n$ (inclusive of the new item):

$$\sigma = \sqrt(M(n) / n)$$

Wellford's approach allows us to maintain a "streaming standard deviation" using solely the two items we've previously identified as being required for the streaming mean and one additional variable: the estimated standard deviation $\sigma = \sqrt(M(n) / n)$.

Using this approach, we can always "reconstruct" $M(n)$ or $M(n-1)$ from the value of $\sigma$ by squaring $\sigma$ and multiplying the result by $n$ or $n-1$, respectively.


__What Happens if $n$ Grows Very Large?__  

This method of maintaining a streaming mean and standard deviation works well as long as our count of stream items $n$ doesn't get too large. However, if we have a relatively large value for $n$ we run the risk of "overflowing" our computer memory bounds either as a result of the value of $n$ getting too large or by the value of $M(n)$ getting too large. 

One way to address this issue would be to let the value of $n$ grow to some predetermined relatively large maximum value as we observe stream elements and then freeze it. As $n$ grows relatively large, the amount of new information added to the mean by any new observation becomes extremely small, as can be seen by reviewing our equation for the mean: $\mu(new) = \mu(previous) + ((Stream[n] - \mu(previous))/n)$. Since $n$ is in the denominator of our equation, new items end up contributing less and less variability to the mean as the value of $n$ continues to grow. 

This same phenomenon happens with the standard deviation as well: once $n$ is very large, the variability contributed to the standard deviation by any newly observed stream element becomes extremely small. 

Therefore, one could argue that for very large values of $n$, the likely change in either the mean or the standard deviation will be so relatively small that, solely for purposes of avoiding a memory overflow, we'd be justified in simply fixing the value of $n$ at some arbitrarily large (but not too large) value if all we are interested in is maintaining an __*estimate*__ of the mean and standard deviation of the stream of numbers. On the other hand, if we require __*precision*__, freezing the value of $n$ is not truly a valid approach.

In the R function defined below, this issue of a potential memory overflow is not addressed. However, the R code could easily be modified to freeze the value of $n$ at some arbitrary point if required.

__An R Function for Computing a Streaming Mean and Standard Deviation__

We'll need to rewrite our code from above to combine the mean and standard deviation functions to accommodate the three running metrics we'll need to maintain.

```{r}
# Function that calculate the mean of a stream using running totals
stream_mean_sd <- function(Stat_df, vec) {
  
  # get the length of the vector
  VLen = length(vec)
  
  for(i in 1:VLen) {
    # inc number of items observed
    Stat_df$n <- Stat_df$n + 1
    
    # find difference betw observed value and old mean = (Stream[n] - mu(previous))
    delta <- vec[i] - Stat_df$Mu
    
    # Update the value of the mean: mu(new) = mu(previous) + ((Stream[n] - mu(previous))/n)
    Stat_df$Mu <- Stat_df$Mu + delta / Stat_df$n
    
    # reconstruct M if n > 1
    if (Stat_df$n > 1) {
      M_prev <- Stat_df$sigma^2 * (Stat_df$n - 1)
    } else {
      M_prev <- 0
    }
      
    # update value of sum of squares of differences: 
    # M(new) = M(previous) + (Stream[n] - mu(n-1)) * (Stream[n] - mu(n))
    M_new <- M_prev + delta * (vec[i] - Stat_df$Mu)
    
    # calculate the new variance
    new_var <- M_new / Stat_df$n
    
    # calculate new standard deviation
    Stat_df$sigma <- sqrt(new_var)
    
  }

  return(Stat_df)
}
```

Now that we have the function defined we can test it by simulating a stream of data. We'll simulate a stream by passing two separate vectors to the function: the second vector's values will serve as a continuation of the "stream" initiated by the first vector.

```{r}
###########################################################
# 
# MAIN part for testing
# 
###########################################################

# define a variable for count of stream items
n <- 0

# define a variable for the mean estimate
Mu <- 0

# define a variable for the standard deviation estimate
sigma <- 0

# create a dataframe containing each of the 3 required variables
Stat_df <- data.frame(n, Mu, sigma)


# ---------------
# Test data: first vector serves as "start" of data stream
vec <- c(1, 2, 3, 4, 5)

# Get the new mean and standard deviation
Stat_df <- stream_mean_sd(Stat_df, vec)

# display the count, mean, and standard deviation from the first vector
Stat_df

# ---------------
# Now add more data to the stream via another vector
vec <- c(147, -324, 42, 0, 76, 88)

# Get the new mean and standard deviation
Stat_df <- stream_mean_sd(Stat_df, vec)

# display the updated count, mean, and standard deviation
Stat_df
```

The dataframe 'Stat_df' maintains the three relevant variables needed to compute the streaming mean and streaming standard deviation and can be updated whenever the data stream has additional values added to it. 

# ------------------------------------------------
### Citations

B. P. Welford (1962)."Note on a method for calculating corrected sums of squares and products". Technometrics 4(3):419-420.
